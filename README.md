Федеральное   государственное  автономное  образовательное  учреждение   высшего образования «Нижегородский государственный университет
 им. Н.И. Лобачевского»

Институт информационных технологий, математики и механики

Направление: Прикладная математика и информатика

ОТЧЕТ

Тема: 
«Вычисление арифметических выражений»

Выполнила:
студентка группы 0823-1
Сырцева Алина Валерьевна

Место для подписи______________ 


Научный руководитель:
ассистент кафедры МОСТ 
Пирова Анна Юрьевна 

Место для подписи______________ 




г. Нижний Новгород 
2016 г.
Оглавление

Введение	3
1.	Постановка учебно-практической задачи	5
2.	Руководство пользователя	6
3.	Руководство программиста	8
     3.1.Используемые инструменты	8
     3.2.Общая структура проекта	8
     3.3.Описание структуры программы	8
     3.4.Описание модульной структуры программы	10
     3.5.Описание структур данных	11
           3.5.1.Структура данных «список»	11
           3.5.2.Структура данных «стек»	12
           3.5.3.Описание алгоритмов	14
Заключение	18
Список используемой литературы	19
Приложение	20














Введение

В XXI веке наука развивается невероятно быстрыми темпами. Ежедневно возникает необходимость в решении всевозможных расчетных задач, в выполнении огромного объема вычислений и т. д. Для этих целей применяются различные ЭВМ (электронные вычислительные машины), в том числе калькуляторы и современные компьютеры  (суперкомпьютеры, или сверхвычислители). 
Калькулятор реализует один (очень редко - два) из трёх вариантов логики операций, то есть порядка ввода команд, который требуется для выполнения арифметических вычислений - это арифметическая логика, алгебраическая логика и логика вычислений с обратной польской записью. Первые две базируются на инфиксной нотации  (когда в записи формулы знак бинарной операции помещается между операндами). Последний тип логики базируется на так называемой обратной польской нотации  (RPN, Reverse Polish Notation) выражений, в которой сначала записываются подряд значения операндов, а после них — знак выполняемой операции.  Среди обычных инженерных калькуляторов использование RPN является редкостью. Более популярна RPN в программируемых калькуляторах: ее поддерживает множество зарубежных моделей, а среди российских (советских) программируемых калькуляторов до 1985 года вообще все поддерживали исключительно RPN; появившиеся позже модели с алгебраической логикой, программируемые на Basic, так и не стали массовыми.
В данной работе рассматривается именно алгоритм, проводящий вычисления по обратной польской записи. Автоматизация вычисления выражений в обратной польской нотации основана на использовании стека.  Реализация стековой машины, как программная, так и аппаратная, чрезвычайно проста и может быть очень эффективной. Обратная польская запись совершенно унифицирована — она принципиально одинаково записывает унарные, бинарные, тернарные и любые другие операции, а также обращения к функциям, что позволяет не усложнять конструкцию вычислительных устройств при расширении набора поддерживаемых операций. Это и послужило причиной использования обратной польской записи в некоторых научных и программируемых микрокалькуляторах.
В данной работе разработан алгоритм реализации динамической структуры данных стек, основанной на динамической структуре список. В качестве примера реализации стеков, разработан алгоритм преобразования инфиксной записи арифметических выражений в постфиксную. Также в работе представлено описание программы, демонстрирующей работу данного алгоритма, и приведен код.




















1.	Постановка учебно-практической задачи

Формулировка задачи:
Разработать программу, выполняющую перевод арифметического выражения с вещественными числами в постфиксную (польскую) запись и вычисление выражения по постфиксной записи. Выражение в качестве операндов может содержать переменные и вещественные числа. Допустимые операции известны: +, -, /, *, ^. Допускается наличие знака «-» в начале выражения или после открывающей скобки.
Исходные данные:
exprassion - инфиксная запись арифметического выражения.
Требуемый результат:
postfix_notation - массив из структур, объединяющих данные о лексеме, саму лексему и ее тип, в постфиксной нотации.
result - результат вычисления значения выражения по постфиксной нотации
Контрольный пример: 
Пусть exprassion = “(10+2)/6+(-3+5)*2”. Тогда:
 
Рис. 1. 1









2.	Руководство пользователя

1.	Для открытия  исполняемого файла с  лабораторной работой необходимо:
1.1.	Через файловый менеджер открыть папку с проектом _lab3_list, а затем вложенную папку Debug;
1.2.	запустить приложение _lab3_list.exe.
2.	При запуске программы появится запрос:  «Enter the expression: ». Требуется ввести арифметическое выражение (выражение может содержать параметры) (см. рис. 2.1).
 
Рис. 2.1.
3.	Если введенное выражение содержит параметры, на экране появится запрос с просьбой ввести значения данных параметров (см. рис. 2.2).
 
Рис. 2.2.
4.	Далее на экран будет выведено выражение в постфиксной записи и результат вычислений (см. рис. 2.3).
 
Рис. 2.3.
5.	Для выхода требуется нажать любую клавишу.



















3.	Руководство программиста
3.1.	Используемые инструменты

В ходе лабораторной работы использовались следующие инструменты:
•	Система контроля версий Git.
•	Фреймворк для написания автоматических тестов Google Test.
•	Среда разработки Microsoft Visual Studio (2010 или старше).
3.2.	Общая структура проекта

•	gtest - библиотека Google Test;
•	include - директория для размещения заголовочных файлов;
•	samples - директория для размещения тестового приложения;
•	sln - директория с файлами решений и проектов для Visual Studio 2010;
•	src - директория для размещения исходных кодов (cpp-файлы);
•	test - директория с модульными тестами и основным тестовым приложением, инициализирующим запуск тестов.
Служебные файлы:
•	.gitignore — перечень расширений файлов, игнорируемых Git при добавлении файлов в репозиторий.
3.3.	Описание структуры программы

	Программа состоит из трех проектов:
1.	gtest.lib - статическая библиотека, позволяющая использовать библиотеку   для модульного тестирования на языке С++  Google C++ Testing Framework (Google Test) для тестирования работоспособности программы. Содержит файлы gtest.h и gtest-all.cc;
2.	_lab3_list - проект, содержащий интерфейс и реализацию списка, стека (на основе списка), а также набор функций, позволяющих разбивать выражение на лексемы, переводить выражение в постфиксную запись и вычислять значение выражения по его постфиксной нотации. Содержит файлы List.h, Stack.h, Parser.h, Arithmetic.h и main.cpp;
3.	test - проект, тестирующий работоспособность списка, стека и арифметических выражений. Содержит файлы test_main.cpp, test_list.cpp, test_stack.cpp и test_arithmetic.cpp.
Файлы:
1.	gtest.h - заголовочный файл Google Test для тестирования работоспособности программы;
2.	gtest-all.cc - реализация системы Google Test для тестирования работоспособности программы;
3.	List.h - заголовочный файл, содержащий динамическую структуру данных односвязный список с соответствующим интерфейсом шаблонного класса List и реализациями методов класса;
4.	Stack.h - заголовочный файл, содержащий динамическую структуру данных стек с соответствующим интерфейсом шаблонного класса Stack, агрегирующего в себе шаблонный класс List, и реализациями методов класса;
5.	Parser.h - заголовочный файл, содержащий реализацию функций, позволяющих разбивать выражение на лексемы;
6.	Arithmetic.h - заголовочный файл, содержащий реализацию функций, позволяющих переводить выражение в постфиксную запись и вычислять значение выражения по его постфиксной нотации;
7.	main.cpp - файл, содержащий реализацию консольного интерфейса пользователя;
8.	test_main.cpp  - файл, позволяющий подключить Google C++ Testing Framework в данный проект;
9.	test_list.cpp - файл, содержащий тесты для проверки работоспособности шаблонного класса List;
10.	test_list.cpp - файл, содержащий тесты для проверки работоспособности шаблонного класса Stack;
11.	test_arithmetic.cpp - файл, содержащий тесты для проверки работоспособности функций, позволяющих переводить выражение в постфиксную запись и вычислять значение выражения по его постфиксной нотации. 
3.4.	Описание модульной структуры программы

Файл Parser.h содержит структуру  Tokens, содержащую поля:
•	char Token [255]; // лексема
•	char TokenType [20]; // тип лексемы
Также Parser.h  содержит реализацию следующей функции:
Tokens * Tokenization (char * expr) // разбиение исходного арифметического выражения на лексемы 

Файл arithmetic.h содержит реализацию следующей функции:
1.	int OperationPriority (char op) // определение приоритета операции
Данная функция принимает на вход оператор, определяет и возвращает соответствующий ему приоритет.
2.	Tokens * ConversionToPostfixNotation (char * expr, int & toknumb) // преобразование к ОПН (обратной польской нотации)
Данная функция принимает на вход выражение в инфиксной записи, преобразует его в постфиксную запись и возвращает массив структур, объединяющих лексемы и типы данных лексем в постфиксной записи; число лексем в обратной польской нотации передается по ссылке.
3.	double Operation (double a, double b, char op) // совершение операции
Данная функция принимает на вход два операнда и оператор и вычисляет результат операции. Возвращается вещественное значение результата.

4.	double Calculation (Tokens * pn, int toknumb) // окончательный подсчет значения выражения
Данная функция принимает на вход массив структур, объединяющих лексемы и типы данных лексем в постфиксной записи, и вычисляет значение выражения. Возвращается вещественное значение равное значению исходного выражения в инфиксной записи.
3.5.	Описание структур данных
3.5.1.	 Структура данных «список»

Односвязный линейный список - динамическая структура данных, состоящая из однотипных «узлов», каждый из которых содержит данные определенного типа и указатель на последующий узел списка. Последний элемент списка указывает на NULL (см. рис. 3.1). Указателем на список является указатель на его первый элемент (Head).



 1

Рис. 3.1.
Принципиальным преимуществом перед линейным массивом является структурная гибкость: порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.
В данной лабораторной работе структура данных «список» представлена в виде шаблонного класса List, который содержит следующие методы:
•	List (int s = 0); // конструктор по умолчанию
•	~ List (); // деструктор
•	int GetSize () const; // получение размера списка
•	int IsEmpty () const; // проверка на пустоту
•	void InsertInTheHead  (ValType _data); // вставка звена с заданным ключом в начало списка
•	void InsertInTheTail (ValType _data); // вставка звена с заданным ключом в конец списка
•	void InsertAfterPointer (ValType _data, Node <ValType> * ptr); // вставка звена с заданным ключом после указателя
•	ValType RemoveFromTheHead (); // удаление звена из начала списка
•	void RemoveFromTheTail (); // удаление звена из конца списка
•	void RemoveAfterPointer (Node <ValType> * ptr); // удаление звена после указателя
•	Node <ValType> * SearchByKey (ValType _data); // поиск звена по ключу
•	ValType ViewPointerData (Node <ValType> * ptr); // получить данные звена
•	ValType ViewHeadData (); // получить данные головы списка
•	ValType ViewTailData (); // получить данные хвоста списка
•	void PrintList (); // печать списка

Представленный набор методов достаточен для реализации других структур данных, например, стеков, с использованием этого класса, а так же для решения типовых задач. 
Класс List реализован с использованием шаблонов для покрытия его использования с различными типами данных.
3.5.2.	 Структура данных «стек»

Стек - динамическая структура данных, представляющая собой список элементов, организованных по принципу FILO (first in - last out, «последним пришёл - первым вышел»).
В данной лабораторной работе структура данных "стек" реализована в виде односвязного линейного списка, то есть каждый элемент содержит помимо хранимой информации в стеке указатель на следующий элемент стека (см. рис. 3.2).


 1

Рис. 3.1.


Программный вид стека используется для обхода структур данных, например, дерево или граф. При использовании рекурсивных функций также будет применяться стек, но аппаратный его вид. Кроме этих назначений, стек используется для организации стековой машины, реализующей запись и вычисления в постфиксной форме арифметических выражений (последний алгоритмы реализован в данной лабораторной работе в качестве примера использования стеков).
В данной лабораторной работе структура данных "стек" представлена в виде класса Stack, который агрегирует в себя объект класса List и содержит следующие методы:
•	Stack (); // конструктор по умолчанию, который явно вызывает конструктор класса List
•	~ Stack (); // деструктор
•	int StackIsEmpty () // метод проверки стека на пустоту
•	void Push (const ValType _data); // метод добавления элемента с заданным значением на вершину стека
•	ValType Pop (); // метод изъятия элемента с вершины стека; метод возвращает значение элемента
•	ValType ViewTop (); // метод просмотра элемента на вершине стека
•	void PrintStack (); // печать стека

Методы, реализованные в классе Stack необходимы и достаточны для полноценного использования этой структуры данных. 
Класс Stack реализован с использованием шаблонов для покрытия его использования с различными типами данных.
3.5.3.	 Описание алгоритмов

Описание наиболее важных алгоритмов необходимых для подсчета арифметических выражений:
1.	Алгоритм определения приоритета операции:
Функция получает символ – оператор.
1.1.	Создается переменная prior, в которой будет хранится число, обозначающее приоритет операции;
1.2.	 При помощи оператора switch происходит определение приоритета:
•	Если оператор – ^, то приоритет равен 4;
•	Если оператор – * или /, то приоритет равен 3;
•	Если оператор – + или -, то приоритет равен 2;
•	Если оператор – ( или ), то приоритет равен 1.
Функция возвращает значение переменной prior.

2.	Алгоритм разбиения выражения на лексемы:
На вход функция получает исходное выражение в инфиксной записи. Выражение просматривается слева-направо:
2.1.	Создается массив toks структур, объединяющих поле массив символов для самой лексемы Token [255] и поле массив символов для наименования типа данной лексемы TokenType [20].
2.2.	Счетчики i = 0, j = 0:
2.2.1.	пока встречаются символы пробела, счетчик увеличивается;
2.2.2.	если встретился символ ‘-‘, то, начиная со следующего символа, пока встречаются цифры, каждый символ записывается в соответствующую структуру toks [j] в поле Token; в поле TokenType структуры toks [j] копируется строка  “Number”.
2.2.3.	если встретился оператор, то он записывается в toks [0] в поле Token, а в поле TokenType копируется строка  “Operator”.
2.2.4.	если встретилась открывающая скобка, то она записывается в toks [j] в поле Token, а в поле TokenType копируется строка  “ Opening bracket”.
2.2.5.	если встретилась закрывающая скобка, то она записывается в toks [j] в поле Token, а в поле TokenType копируется строка  “ Closing bracket”.
2.2.6.	если встретилась буква латинского алфавита (верхнего или нижнего регистра), то появляется запрос с просьбой ввести значение параметра (число с плавающей точкой); введенное пользователем значение записывается в toks [j] в поле Token, а в поле TokenType копируется строка  “ Number”.
2.2.7.	Если встретилась цифра, то, начиная со следующего символа, пока встречаются цифры, каждый символ записывается в соответствующую структуру toks [j] в поле Token; в поле TokenType структуры toks [j] копируется строка  “Number”.
2.3.	Счетчики увеличиваются.
2.4.	Цикл oт i до длины исходной строки len:
2.4.1.	пока встречаются символы пробела, счетчик увеличивается;
2.4.2.	если встретился символ ‘-‘, то, если предыдущий ((i-1) - ый) символ – открывающая скобка, то, начиная со следующего символа, пока встречаются цифры, каждый символ записывается в соответствующую структуру toks [j] в поле Token; в поле TokenType структуры toks [j] копируется строка  “Number”.
2.4.3.	если встретился оператор, то он записывается в toks [0] в поле Token, а в поле TokenType копируется строка  “Operator”.
2.4.4.	если встретилась открывающая скобка, то она записывается в toks [j] в поле Token, а в поле TokenType копируется строка  “ Opening bracket”.
2.4.5.	если встретилась закрывающая скобка, то она записывается в toks [j] в поле Token, а в поле TokenType копируется строка  “ Closing bracket”.
2.4.6.	если встретилась буква латинского алфавита (верхнего или нижнего регистра), то появляется запрос с просьбой ввести значение параметра (число с плавающей точкой); введенное пользователем значение записывается в toks [j] в поле Token, а в поле TokenType копируется строка  “ Number”.
2.4.7.	Если встретилась цифра, то, начиная со следующего символа, пока встречаются цифры, каждый символ записывается в соответствующую структуру toks [j] в поле Token; в поле TokenType структуры toks [j] копируется строка  “Number”.
2.4.8.	Счетчик j увеличивается.

Функция возвращает массив структур. 

3.	Алгоритм перевода выражения в обратную польскую запись:
На вход функция получает исходное выражение.
3.1.	Создаем стек для хранения операций <Tokens> OperationStack.
3.2.	Разделяем выражение на лексемы.
3.3.	Читаем очередную лексему.
3.4.	Если лексема является числом, добавляем ее в выходную строку. 
3.5.	Если лексема является открывающей скобкой, помещаем ее в стек.
Если символ является закрывающей скобкой, то пока стек не пуст, выполняем: пока верхним элементом стека не станет открывающая скобка, выталкиваем элементы из стека в выходную строку; при этом открывающая скобка удаляется из стека, но в выходную строку не добавляется. Если стек закончился раньше, чем мы встретили открывающую скобку, то в выражении либо неверно поставлен разделитель, либо не согласованы скобки.
3.6.	Пока приоритет оператора меньше приоритета оператора, находящегося на вершине стека, выталкиваем верхний элемент стека в выходную строку и помещаем оператор в стек.
3.7.	Когда входная строка закончилась, выталкиваем все символы из стека в выходную строку. В стеке должны были остаться только символы операторов, Если это не так, значит в выражении не согласованы скобки.
Функция возвращает массив структур в обратной польской записи.

4.	Алгоритм подсчета значения арифметического выражения:
На вход функция получает  массив структур, полученный в результате перевода выражения в обратную польскую запись.  
4.1.	Создается стек с вещественным типом данных _Stack.
4.2.	Выражение просматривается слева-направо, и при этом возможно 2 случая:
4.2.1.	Встретилось число. В этом случае оно переводится из символьного формата в вещественный  и добавляется на вершину стека _Stack.
4.2.2.	Встретился оператор. Тогда из стека _Stack изымаются 2 операнда, над ними совершается операция, результат операции снова добавляется в стек.
4.3.	При достижении конца арифметического выражения, в стеке будет находиться единственный элемент - численный результат выражения.
Функция его возвращает.












Заключение

В ходе лабораторной работы была разработана программа, удовлетворяющая поставленным задачам. Программа выполняет перевод арифметического выражения с вещественными числами в постфиксную (польскую) запись и вычисление выражения по постфиксной записи.
Структуры список и стек были реализованы с использованием шаблонных классов, так как этого требовал алгоритм преобразования записи выражения. 
В процессе работы было написано 32 теста, которые покрывают различные ситуации использования методов классов и функций. Все тесты были успешно пройдены.


















Список используемой литературы

•	http://cppstudio.com
•	Павловская Т.А. C/C++ Программирование на языке высокого уровня. – СПб.: Питер, 2003. – 461 с.: ил.
•	Альфред В. Ахо, Джон Хопкрофт, Джеффри Д. Ульман. Структуры данных и алгоритмы = Data Structures and Algorithms. — М.: Вильямс, 2000. — 384 с.
•	Майкл Мейн, Уолтер Савитч. Структуры данных и другие объекты в C++ = Data Structures and Other Objects Using C++. — 2-е изд. — М.: Вильямс, 2002. — 832 с.


















Приложение
	
Приложение 1
Файл List.h:
#ifndef __LIST_H__
#define __LIST_H__


#include <cstdlib>
#include <iostream>

using namespace std;


// Класс Список

template <class ValType>
struct Node {
	ValType Data; // информационное поле
	Node <ValType> * Next; // указатель связи
};

template <class ValType>
class List
{
protected:
	Node <ValType> * Head;
	int Size;
public:

	List (int s = 0) // конструктор по умолчанию
	{
		if (s >= 0)
		{
			Size = s;
			Head = NULL;
		}
		else
			throw 1;
	};

	~ List (); // деструктор

	int GetSize () const // получить размер списка
	{
		return Size;
	}

	int IsEmpty () const // проверка на пустоту
	{ 
		if (Head) 
			return 0; 
		return 1; 
	}

	void InsertInTheHead  (ValType _data); // вставка звена с заданным ключом в начало списка
	void InsertInTheTail (ValType _data); // вставка звена с заданным ключом в конец списка
	void InsertAfterPointer (ValType _data, Node <ValType> * ptr); // вставка звена с заданным ключом после указателя

	ValType RemoveFromTheHead (); // удаление звена из начала списка
	void RemoveFromTheTail (); // удаление звена из конца списка
	void RemoveAfterPointer (Node <ValType> * ptr); // удаление звена после указателя

	Node <ValType> * SearchByKey (ValType _data); // поиск звена по ключу

	ValType ViewPointerData (Node <ValType> * ptr) // получить данные звена
	{
		return (ptr -> Data); 
	}	

	ValType ViewHeadData () // получить данные головы списка
	{
		return (Head -> Data); 
	}	

	ValType ViewTailData () // получить данные хвоста списка
	{
		Node <ValType> * tmp = Head;
		while (tmp -> Next != NULL) 
			tmp = tmp -> Next;
		return tmp -> Data; 
	}

	void PrintList (); // печать списка
};

template <class ValType>
List <ValType> :: ~ List ()
{
	Node <ValType> * tmp;
	while (Head)
	{
		tmp = Head -> Next;
		delete Head;
		Head = tmp;
	}
}

template <class ValType>
void List <ValType> :: InsertInTheHead (ValType _data)
{
	Node <ValType> * tmp = new Node <ValType>;

	tmp -> Data = _data;
	tmp -> Next = Head;


	Head = tmp;
	Size ++;
}

template <class ValType>
void List <ValType> :: InsertInTheTail (ValType _data)
{
	if (IsEmpty ()) 
	{ 
		InsertInTheHead (_data); 
		return;
	}
	Node <ValType> * tmp = new Node <ValType>;

	tmp -> Data = _data;
	tmp -> Next = NULL;

	Node <ValType> * ptr = Head;
	while (ptr -> Next != NULL) 
		ptr = ptr -> Next;
	ptr -> Next = tmp;
	Size ++;
}

template <class ValType> 
void List <ValType> :: InsertAfterPointer (ValType _data, Node <ValType> * ptr)
{
	if (ptr)
	{
		Node <ValType> * tmp = new Node <ValType>;

		tmp -> Data = _data;
		tmp -> Next = ptr -> Next;

		ptr -> Next = tmp;
		Size ++;
	}
	else
	{
		Node <ValType> * tmp = new Node <ValType>;

		tmp -> Data = _data;
		tmp -> Next = NULL;


		Head = tmp;
		Size ++;
	}
}

template <class ValType> 
ValType List <ValType> :: RemoveFromTheHead ()
{
	if (Head != NULL) 
	{
		ValType top = Head -> Data;
		Node <ValType> * tmp = Head -> Next;
		delete Head;
		Head = tmp;
		Size --;
		return top;
	}
	else
		throw 1;
}

template <class ValType> 
void List <ValType> :: RemoveFromTheTail ()
{
	if (Size == 1)
	{
		delete Head;
		Head = NULL;
		Size --;
	}
	else if (Size > 0)
	{

		Node <ValType> * tmp = Head;
		while (tmp -> Next -> Next)
		{
			tmp = tmp -> Next;
		}
		delete tmp -> Next;
		tmp -> Next = NULL;
		Size --;
	}
	else
		throw 1;
}

template <class ValType>
void List <ValType> :: RemoveAfterPointer (Node <ValType> * ptr)
{
	if (Size == 1)
	{
		delete Head;
		Head = NULL;
		Size --;
	}
	else if (Size > 0)
	{
		Node <ValType> * tmp = ptr -> Next -> Next;
		delete ptr -> Next;
		ptr -> Next = tmp;
		Size --;
	}
	else
		throw 1;
}

template <class ValType> 
Node <ValType> * List <ValType> :: SearchByKey (ValType _data)
{
	if (Size > 0)
	{
		Node <ValType> * tmp = Head;
		while (tmp != NULL)
		{
			if (tmp -> Data == _data)
				break;	
			else
				tmp = tmp -> Next;
		}
		return tmp;
	 }
	else
		throw 1;
}

template <class ValType> 
void List <ValType> :: PrintList ()
{
	Node <ValType> * tmp = Head;
	while (tmp)
	{
		cout << tmp -> Data << endl;
		tmp = tmp -> Next;
	} 
}

#endif

Приложение 2
Файл Stack.h

#ifndef __STACK_H__
#define __STACK_H__

#include "List.h"

// Класс Стек

template <class ValType>
class Stack 
{
protected:
	List <ValType> Mem;
public:
	Stack (); // конструктор по умолчанию, который явно вызывает конструктор класса List
	~ Stack (); // деструктор
	int StackIsEmpty () // метод проверки стека на пустоту
	{
		return Mem.IsEmpty ();
	}
	void Push (const ValType _data); // метод добавления элемента с заданным значением на вершину стека
	ValType Pop (); // метод изъятия элемента с вершины стека; метод возвращает значение элемента
	ValType ViewTop (); // метод просмотра элемента на вершине стека
	void PrintStack (); // печать стека
};


template <class ValType> 
Stack <ValType> :: Stack () 
{
}

template <class ValType> 
Stack <ValType> :: ~ Stack () 
{
}

template <class ValType> 
void Stack <ValType> :: Push (const ValType _data)
{
	Mem.InsertInTheHead (_data);
};

template <class ValType> 
ValType Stack <ValType> :: Pop ()
{
	ValType top = Mem.RemoveFromTheHead ();
	return top;
};

template <class ValType> 
void Stack <ValType> :: PrintStack ()
{
	Mem.PrintList ();
}

template <class ValType> 
ValType Stack <ValType> :: ViewTop ()
{
	ValType top = Mem.ViewHeadData ();
	return top;
};

#endif

Приложение 3
Файл Parser.h

#ifndef __PARSER_H__
#define __PARSER_H__

#include <cstring>
#include <cctype>
#include <iostream>
#include <cstdlib>
#include <cmath>

using namespace std;

struct Tokens
{
	char Token [255]; // лексема
	char TokenType [20]; // тип лексемы
};

Tokens * Tokenization (char * expr) // разбиение исходного арифметического выражения на лексемы 
{
	int len = strlen (expr);
	Tokens toks [255];
	int i = 0;
	int j = 0;

	if (expr [i] == '\0')
		throw 1;

    while (isspace (expr [i])) // Пропустить разделительные символы
		i ++; 
	
	if (expr [i] == '-')
	{
		int k = 1;

		toks [j].Token [0] = expr [i];
        while ((isdigit (expr [i + 1])) || (expr [i + 1] == '.'))
		{
			toks [j].Token [k] = expr [i + 1];
			k ++;
			i ++;
		}
		toks [j].Token [k] = '\0';
		
		strcpy_s (toks [j].TokenType, "Number");

		j ++;
	}


    else if (strchr ("+-*/^", expr [i]))
    {
		toks [j].Token [0] = expr [i];
		toks [j].Token [1] = '\0';

		strcpy_s (toks [j].TokenType, "Operator");

		j ++;
    }

	else if (expr [i] == '(')
	{
		toks [j].Token [0] = expr [i];
		toks [j].Token [1] = '\0';

		strcpy_s (toks [j].TokenType, "Opening bracket");

		j ++;
	}

	else if (expr [i] == ')')
	{
		toks [j].Token [0] = expr [i];
		toks [j].Token [1] = '\0';

		strcpy_s (toks [j].TokenType, "Closing bracket");

		j ++;

	}

    else if (isalpha (expr [i]))
    {
		char numb [255];
		cout << "Enter the value of the variable " << expr [i] << ": " << endl;
		cin >> numb;
		cout << endl;

		unsigned  int k = 0;
		while (k < strlen (numb))
		{
			toks [j].Token [k] = numb [k];
			k ++;
		}
		toks [j].Token [k] = '\0';

		strcpy_s (toks [j].TokenType, "Number");

		j ++;
    }

    else if (isdigit (expr [i]))
    {
		int k = 1;
		toks [j].Token [0] = expr [i];
        while ((isdigit (expr [i + 1])) || (expr [i + 1] == '.'))
		{
			toks [j].Token [k] = expr [i + 1];
			k ++;
			i ++;
		}
		toks [j].Token [k] = '\0';

		strcpy_s (toks [j].TokenType, "Number");

		j ++;

    }

	else
		throw 1;

	i ++; 

    for (; i < len; i ++)
	{

	while (isspace (expr [i])) // Пропустить разделительные символы
		i ++; 

	if ((expr [i] == '-') && (expr [i - 1] == '('))
	{
		int k = 1;

		toks [j].Token [0] = expr [i];
        while ((isdigit (expr [i + 1])) || (expr [i + 1] == '.'))
		{
			toks [j].Token [k] = expr [i + 1];
			k ++;
			i ++;
		}
		toks [j].Token [k] = '\0';

		strcpy_s (toks [j].TokenType, "Number");

		j ++;
	}


    else if (strchr ("+-*/^", expr [i]))
    {
		toks [j].Token [0] = expr [i];
		toks [j].Token [1] = '\0';

		strcpy_s (toks [j].TokenType, "Operator");

		j ++;
    }

	else if (expr [i] == '(')
	{
		toks [j].Token [0] = expr [i];
		toks [j].Token [1] = '\0';

		strcpy_s (toks [j].TokenType, "Opening bracket");

		j ++;
	}

	else if (expr [i] == ')')
	{
		toks [j].Token [0] = expr [i];
		toks [j].Token [1] = '\0';


		strcpy_s (toks [j].TokenType, "Closing bracket");

		j ++;

	}


	else if (isalpha (expr [i]))
    {
		char numb [255];
		cout << "Enter the value of the variable " << expr [i] << ": " << endl;
		cin >> numb;
		cout << endl;

		unsigned int k = 0;
		while (k < strlen (numb))
		{
			toks [j].Token [k] = numb [k];
			k ++;
		}
		toks [j].Token [k] = '\0';

		strcpy_s (toks [j].TokenType, "Number");

		j ++;
    }



    else if (isdigit (expr [i]))
    {
		int k = 1;

		toks [j].Token [0] = expr [i];
        while ((isdigit (expr [i + 1])) || (expr [i + 1] == '.'))
		{
			toks [j].Token [k] = expr [i + 1];
			k ++;
			i ++;
		}
		toks [j].Token [k] = '\0';

		strcpy_s (toks [j].TokenType, "Number");

		j++;

    }

	else
		throw 1;
	}

	return toks; 
}


#endif


Приложение 4
Файл Arithmetic.h

#ifndef __ARITHMETIC_H__
#define __ARITHMETIC_H__

#include "Stack.h"
#include "Parser.h"
#include <cstring>
#include <cctype>
#include <iostream>
using namespace std;

int OperationPriority (char op) // определение приоритета операции
{
	int prior;
	switch (op)
	{
	case '^': { prior = 4; break; }
	case '*': { prior = 3; break; }
	case '/': { prior = 3; break; }
	case '+': { prior = 2; break; }
	case '-': { prior = 2; break; }
	case '(': { prior = 1; break; }
	case ')': { prior = 1; break; }
	default: throw 1;
	}
	return prior;
}


Tokens * ConversionToPostfixNotation (char * expr, int & toknumb) // преобразование к ОПН (обратной польской нотации)
{

	Tokens * toks = Tokenization (expr); // разделяем выражение на лексемы
	Tokens top;

	int len = strlen (expr);
	int i = 0;
	int j = 0;

	Stack <Tokens> OperationStack;

	Tokens Postfix [255]; 

	while (i < len)
	{
		// Читаем очередную лексему

		// Если лексема является числом, добавляем ее в выходную строку
		if (strcmp (toks [i].TokenType, "Number") == 0)
		{
			Postfix [j] = toks [i];
			j ++;
		}

		// Если лексема является открывающей скобкой, помещаем ее в стек 
		else if (strcmp (toks [i].TokenType, "Opening bracket") == 0)
			OperationStack.Push (toks [i]);

		// Если символ является закрывающей скобкой: 
		//   до тех пор, пока верхним элементом стека не станет открывающая скобка, выталкиваем элементы из стека в выходную строку
		//   при этом открывающая скобка удаляется из стека, но в выходную строку не добавляется
		// Если стек закончился раньше, чем мы встретили открывающую скобку, то в выражении либо неверно поставлен разделитель, либо не согласованы скобки
		
		else if (strcmp (toks [i].TokenType, "Closing bracket") == 0)
		{
		    int flag = 0;

			while (! OperationStack.StackIsEmpty ())
			{
				if (strcmp (OperationStack.ViewTop ().TokenType, "Opening bracket") != 0)
				{
					top = OperationStack.Pop ();
					Postfix [j] = top;
				    j ++;
				}
				else
				{
					flag = 1;
					break;
				}
			}
			if (flag == 0)
				throw 1;

			top = OperationStack.Pop ();
		}

	
		
		// Пока приоритет оператора меньше приоритета оператора, находящегося на вершине стека,
		//   выталкиваем верхний элемент стека в выходную строку
		// и помещаем оператор в стек
		else if (strcmp (toks [i].TokenType, "Operator") == 0)
		{
			Tokens _t;
			if (OperationStack.StackIsEmpty ())
				OperationStack.Push (toks [i]);
			else
			{
				top = OperationStack.ViewTop ();
				if (OperationPriority (toks[i].Token [0]) > OperationPriority (top.Token [0]))
					OperationStack.Push (toks [i]);

				else
				{
					while (! OperationStack.StackIsEmpty ())
					{
						top = OperationStack.ViewTop ();
						if (OperationPriority (toks[i].Token [0]) <= OperationPriority (top.Token [0]))
						{
							_t = OperationStack.Pop ();
						    Postfix [j] = _t;
						    j ++;
						}
						else
							break;
					}
					OperationStack.Push (toks [i]);
				}
			}
		}

		i ++;
	}

	Tokens _t;

	// Когда входная строка закончилась, выталкиваем все символы из стека в выходную строку. 
	// В стеке должны были остаться только символы операторов; если это не так, значит в выражении не согласованы скобки.

	while (! (OperationStack.StackIsEmpty ()))
	{
		_t = OperationStack.Pop ();
		if (strcmp (_t.TokenType, "Operator") == 0)
		{
		    Postfix [j] = _t;
		    j ++;
		}
		else
			throw 1;
	}
	
	 toknumb = j;

	return Postfix;
}


double Operation (double a, double b, char op) // совершение операции
{
	switch (op)
	{
	case '+': { return a + b; break; }
	case '-': { return a - b; break; }
	case '*': { return a * b; break; }
	case '/': { return a / b; break; }
	case '^':
		{
			double res = a;
		    for (int i = 1 ; i < b ; i++)
			res = res * a;
			return res;
			break;
		}

		default: throw 1;
    }
}

double Calculation (Tokens * pn, int toknumb) // окончательный подсчет значения выражения
{
	double res;
	Stack <double> _Stack;
	for (int i = 0; i < toknumb; i ++)
	{
		if (strcmp (pn [i].TokenType , "Number") == 0)
			_Stack.Push (atof (pn [i].Token));
		else
		{
			double b = _Stack.Pop ();
			double a = _Stack.Pop ();
			res = Operation (a, b, pn [i].Token [0]);
			_Stack.Push (res);
		}
	}

	return res;
}

#endif

Приложение 5
Файл main.cpp

#include "Arithmetic.h"
#include "Parser.h"

#include <cstdlib>

int main ()

{
	cout << "_______________________________________________________________" << endl;
	cout << "     THE CONVERSION OF THE EXPRESSION FROM INFIX NOTATION      " << endl;
	cout << "            TO POSTFIX (REVERSE POLISH) NOTATION               " << endl;
	cout << "_______________________________________________________________" << endl;
	cout << endl;

	
	char exprassion [255];

	cout << "Enter the expression:" << endl;
	cin >> exprassion;

	cout << endl;

	int tok_numb = 0;
	Tokens * postfix_notation = ConversionToPostfixNotation (exprassion, tok_numb);


	cout << "The expression in the postfix form: " << endl;
	for (int i = 0; i < tok_numb; i ++)
		cout << postfix_notation [i].Token << ' ';

	cout << endl;
	cout << endl;

	double result = Calculation (postfix_notation, tok_numb);
	cout << "The result of the calculation: " << result << endl;
	cout << endl;

	return 0;
}
